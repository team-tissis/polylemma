# README 草案

ASSIGNEE: shue shiinoki, Anonymous
DOC TYPE: documentation
LAST UPDATED: November 6, 2022 6:38 PM
STATUS: PROGRESS
progress percentage: 0.4

# POLYLEMMA: Commit-Reveal Scheme を応用したフルオンチェーンPvPコマンドバトルゲーム

# 概要

GameFi では Earn できることからそのエコシステムがゲーム内に閉じておらず、外の世界に影響が伝播する。故にゲームの都合だけで状態を巻き戻すことが困難なため、普通のゲーム以上に不正や改竄の検知が重要になる。そのためフルオンチェーンでゲームを行いたいが、ブロックチェーンの公開台帳的な性質によって得られる”透明性”と情報を完全に公開しないことでゲームの面白さを引き出す”表現力”のトレードオフが発生する。オンチェーンに載せるという制約によってゲーム内で実現できる表現の幅が狭まり、ゲームの面白みが失われる可能性があるのだ。

今回我々はフルオンチェーンでも表現力を担保するために、***Commit-Reveal Scheme を応用した新しいプロトコルを考案***した。そしてこのプロトコルを用いて“同時に出す”、”隠す”という要素を盛り込んだフルオンチェーンPvPコマンドカードバトルゲームPOLYLEMMAを開発した。このプロトコルは GameFi に限らず、***オンチェーンにおける改竄耐性や不正検知能力といった”透明性”の高さを生かしつつ、同時に”表現力”も保ちたい幅広い場面に応用***できるプロトタイプとなっている。

(498字)

# Contract Address

```solidity
旧版
PLMCoin contract: "0xC2F6e5d1bf568f61a0C3e302ba88C1580688F2a5”
PLMToken contract: "0x42c788e4c7532B46935FC36d5867c78dB716Dc3D”
PLMDealer contract: "0x27a22Cc6Acab236AFAcd54F7A9e3a77D2e9a0EBb”
PLMMatchOrganizer contract: "0x36A0f7aF7F839219692107501bB03079fE788021”
PLMBattleField contract: "0x1652c915B83F1cb2b3966258CD42aBdE558dAC2d”
```

```solidity
新版
PLMCoin contract: "0x3339F7b5a9732A89A97784da603db81e4e36De21"
PLMToken contract: "0xB26c1c4F3943632C5320e81154DEde5F70541F8d"
PLMDealer contract: "0x7DE60Bfe97DBF9e187cC60968abD5Ee86551041B"
PLMMatchOrganizer contract: "0xcC1E6B11FBB87b8Bb8b33A8fB3261A0DaEb7fda6"
PLMBattleField contract: "0x6a4ED9Ac7f80222df4683B15acEB7996fa98ec2A"
```

# 全体のアーキテクチャ図

![スマートコントラクト同士の関係図。矢印はどのような操作を依頼するかを表している。](README%20%E8%8D%89%E6%A1%88%2006ef9071268745e48c0cb1e9e868558a/Untitled.png)

スマートコントラクト同士の関係図。矢印はどのような操作を依頼するかを表している。

# 使用したチェーン

![Untitled](README%20%E8%8D%89%E6%A1%88%2006ef9071268745e48c0cb1e9e868558a/Untitled%201.png)

Mumbai Testnet

# 使っている技術スタック

Solidity, Foundry, Anvil, Cast, NodeJS, EtherJS, React

## 主な開発分担

バックエンドの開発: Kosei Teramoto, Shue Shiinoki

フロントエンドの開発: Nobuho Hashimoto, Atsushi Kato


# ゲームの要素とその実現方法について

## キャラクター (PLMToken)

![ガチャで引かれることによって、OpenSea(テストネットワーク版)上でもキャラの情報が閲覧可能となっている。](README%20%E8%8D%89%E6%A1%88%2006ef9071268745e48c0cb1e9e868558a/Untitled%2010.png)

ガチャで引かれることによって、OpenSea(テストネットワーク版)上でもキャラの情報が閲覧可能となっている。

@shue shiinoki 

PLMTokenはERC721トークンとして実装されています。

プレイヤーは所持するキャラクターを育成し、バトルで使用することができます。

キャラクターはレベル、属性、特性、絆レベルを持ちます。

レベルはキャラクターの基礎攻撃力を表しており、PLMCoinをゲームコントラクトに支払うことでレベルアップすることができます。

属性：

自分と攻撃相手の属性の組み合わせによって有利だとダメージが20%増加、不利だと20%減少します。

特性；

キャラクターごとに持つ特殊能力（いわゆるパッシブスキル）です。それぞれのキャラクターが1つだけ持っており、属性相性とは別にダメージ計算やその他のバトル要素に影響を及ぼします。

絆レベル：
プレイヤーがそのキャラクターの所有者となってからのブロック時間が経過するほど増える数値です。この数値に応じて、キャラクターのレベルは元の値の2倍まで増加します。

より長く所持しているキャラクターが強くなるようにすることで、所持している既出キャラクターが新規キャラクターの登場によって相対的に弱体化することを抑制しています。この数値はミント時や譲渡時といった所有者が変更されるタイミングで初期化されます。

$p_{own}$: 所有ブロック期間、$p_{\rm{speed}}$ : 絆レベル上昇速度を決める定数、$l$ : キャラクターの現在のレベルから、絆レベル $b$ は以下計算式で算出されます。

$$
b = \max\left(\frac{p_{\rm{own}}}{p_{\rm{speed}}}, 2l\right)
$$

絆レベルが多い分だけ、攻撃力が上がります。通常のレベルと絆レベルを組み合わせたダメージ計算は以下の通りで、絆レベル分の内訳は1ポイント当たり1/10となっています。

$$
{\rm{damage}} = 10 l + b 
$$

データ構造：

キャラクターに紐づくこれらの情報は変更が生じるたびにその履歴がブロックバンバーと共に保存されており、チェックポイントとして格納されています。この実装により、***バトル中など、ある時点でのキャラクター情報を継続的に参照する必要がある際に、キャラクターのtransferやレベルアップなどの書き換えが実施されたとしても、元の情報を参照し続けることが可能になります。*（**チェックポイントについては Nouns DAO の proposal 時点での delegate を参照する実装に影響を受けています。）

キャラクター画像：

弊チームにイラストを書けるメンバーがいなかったため、Stable Diffusion ([https://stability.ai/](https://stability.ai/)) によって作成しました。

## ゲーム内通貨 (PLMCoin) とトークノミクス

PLMCoinはERC20トークンとして実装されています。

PLM Coin は、ガチャ（NFT獲得）、キャラクター育成、サブスクリプションに使用します。

プレイヤーはMATICを一定額支払う課金か、ゲームに勝利することでPLMCoinを入手することが可能です。

初期ミントを除いたPLMCoinの発行は課金が実行された際に行われます。1 MATICに対して 1 PLMCoin が発行されますが、プレイヤーが受け取るPLMCoinは、発行分から手数料（ゲームコントラクトが受領）を除いた分です。

ゲームの勝利報酬はゲームコントラクトの残高より支払われます。

外部からの資金流入はプレイヤー課金で、プレイヤーにとってのPLM Coin収入源はバトル報酬のみとなっており

現時点では、pay to win を抑止するため、累進課税のような形で手数料が課金額に対応して増額される機構を導入しています。今後のアップデートで、ゲームバランスの調整により、free to win な構成にシフトしていく予定です。

![Untitled](README%20%E8%8D%89%E6%A1%88%2006ef9071268745e48c0cb1e9e868558a/Untitled%2011.png)

## ガチャ

プレイヤーはPLMCoinを支払うことでキャラクター (PLMToken) をミントするガチャを回すことができます。ガチャではミントをPLMGacha コントラクトが実行しそれをプレイヤーにtransferする形で実装されています。これにより、そのキャラクターの最初の所有者としてゲームコントラクトアドレスが記録されるので、そのPLM Tokenが公式のものであることが証明されます。（これはNouns DAO ([https://nouns.wtf/](https://nouns.wtf/)) でTokenがオークションにかけられる際に一度 AuctionHouse Contract がミントを実行してから落札者にtransferされる実装に影響を受けています。）

ミント時にキャラクター画像ID、属性、特性がランダムに決定します。キャラクター画像はオフチェーンに保存したものからランダムに選択され、特性はその効果によってレア度が1ー5まで存在し、レア度に応じた排出率となっています。今回乱数の発生にはChainLinkといった別途手数料のかかるオラクルは使用していません。代わりにコントラクト内にて疑似乱数の生成を行っています。その時点まで予測することが困難な最新のブロックハッシュをハッシュ関数に入力して乱数を生成することで、乱数調整を困難にしています。(これはwhelps NFT ([https://whelps.io/](https://whelps.io/)) などで使用されている、スマートコントラクト内で検証可能な疑似乱数を発生させる方法に影響を受けています。) 

![gacha.png](README%20%E8%8D%89%E6%A1%88%2006ef9071268745e48c0cb1e9e868558a/gacha.png)

## スタミナ

プレイヤーはバトルを開始するためにスタミナを一定数消費する必要があります。スタミナは最大値が定められており、消費すると一定速度で回復していきます。また、PLMCoinを使用して全回復することも可能です。

ガス代を削減するため、ブロックチェーン上で保持した値の書き換えはできる限り少なくすることが望ましいです。そこで、各playerのスタミナがゼロであった時点のblock numberを保持し、現時点のスタミナを回復速度から計算する実装としました。スタミナを消費・全回復は保存したblock numberを書き換えることで実現でき、データの書き換え回数を抑えることができます。

![stamina.png](README%20%E8%8D%89%E6%A1%88%2006ef9071268745e48c0cb1e9e868558a/stamina.png)

## サブスクリプション

プレイヤーがゲームに参加するにはサブスクリプションを行う必要があります。PLMCoinを一定数支払うことで、1296000ブロック時間遊ぶことができるようになります。サブスクはplayerごとの期限切れとなるblock numberを保持することで管理しています。

## マッチメイキング

サーバを使用することなくかつ autonomous に2人のプレイヤーのマッチメイクをする場合は、バトルを後からリクエストした方のトランザクションをトリガーとしてバトルをスタートさせる必要があります。そこで、マッチメイク時のプレイヤーの役割を提案者・挑戦者を分けて実装することで、autonomousなマッチメイクを実現しました。

Playerはバトルをする方法は2通りあります。1. バトルを提案して挑戦者を待つ  2. 提案されているバトルに挑戦する の2つです。バトルを提案する側は使用するキャラクターを4体のパーティを組んで提案を作成し、挑戦者を待ちます。この時、バトルを希望する相手のレベル範囲を指定することが可能です。

挑戦する側は、現存している提案のパーティ情報を参照しながら挑戦したい提案を選びます。挑戦したい提案を選び、自分のキャラクターから4体のパーティを組んでバトルをリクエストします。この時、パーティの合計レベルが提案で指定された範囲にする必要があります。

挑戦リクエストが条件を満たしているとバトルに入る処理が呼ばれ、バトルに関するコントラクトが実行可能となり、自動的にバトルに遷移します。

![Untitled](README%20%E8%8D%89%E6%A1%88%2006ef9071268745e48c0cb1e9e868558a/Untitled%2012.png)

## バトルシステム

1ゲーム 1on1 のPvPで、5ラウンド戦い、勝利ラウンド数の大きい方がバトルに勝利します。

プレイヤーはゲーム開始時に自分の所有するキャラの中から選んだ４体からなるパーティーに加え、図鑑に存在するすべてのキャラからランダムに一体選ばれたキャラがランダムスロットに入れられ、合計5体でバトルを開始します。ゲーム開始と同時に、プレイヤーにはレベルポイントと呼ばれるポイントが与えられ、一バトルの中でプレイヤーはキャラを戦いに出す際にレベルポイント分だけレベルを加算することができるようになります。レベルポイントは POLYLEMMA において読み合いを増やすために導入した要素です。双方のキャラが出揃うと、そのキャラのレベル + 付与されたレベルポイントをベースとして、属性の相性とキャラクターの持つと癖が加味されてダメー計算が行われ、勝敗が決まります。これらのロジックはスマートコントラクトに書かれています。

![Untitled](README%20%E8%8D%89%E6%A1%88%2006ef9071268745e48c0cb1e9e868558a/Untitled%2013.png)

ゲームの性質上、キャラクターには相性というものがあるので、相手の出したキャラクターを見てからキャラクターを出すとジャンケンの後出しのように簡単に勝ててしまいます。そのため、コマンドを同時に出す必要があります。ところが、POLYLEMMA はフルオンチェーンゲームなので、コマンドを同時に出す時に**”同時”**を保証することが困難です。POLYLEMMA では Commit-Reveal Scheme を使うことで **“同時”** と同等の処理を実現しました。

### コマンドを出す仕組み

# WIP

以上が Commit-Reveal Scheme を用いた、コマンドを同時に出す仕組みです。POLYLEMA ではもう一つランダムスロット (5体目のモンスターです) という要素を実現していますので、次にそれについて説明していきます。

### ランダムスロット

ランダムスロットは POLYLEMMA にあるゲーム性を高めてゲームを面白くする要素の一つです。ランダムスロットは、***性質1: 自分で意図的に特定のキャラを指定することができない(ランダムに生成されているように見える)*** かつ ***性質2: そのキャラをラウンドでの戦いに出すまでは相手は何のキャラがランダムスロットに入れたれたのかを知ることはできない*** という二つの要素を満たします。ブロックチェーンではトランザクションの履歴が公開される都合上、透明性は担保されますが、逆にこういった相手から “隠す” という要素の実現が難しくなります。以下でランダムスロットをどう実現したかを説明してきます。

![Untitled](README%20%E8%8D%89%E6%A1%88%2006ef9071268745e48c0cb1e9e868558a/Untitled%2014.png)

![Untitled](README%20%E8%8D%89%E6%A1%88%2006ef9071268745e48c0cb1e9e868558a/Untitled%2015.png)

***ここからランダムスロットの実現方法の説明に入ります。少々込み入った内容にはなりますが、今回のプロジェクトの核となる技術要素のため、ぜひ読んでいただきたい部分です。***

性質1を愚直に満たそうとするなら、ゲームを執り行うコントラクトからプレイヤーに乱数を配布するという方法が考えられます。その乱数 $r$ をハッシュ関数 $h$ に通して、図鑑にあるキャラクターの総数 $n$ で剰余を取ることでランダムスロットに選ばれるキャラクターの番号 $id$ は

$$
id = h(r)\mod\ n
$$

で定義すれば良いでしょう。ところが、この方法では性質2が満たされないことがすぐにわかります。というのも、スマートコントラクトからユーザーに乱数を配った場合、それは当然トランザクションとして実行されるわけですから、相手からも丸見えになります。そのため、相手が自分のランダムスロットを定義するために発行された乱数を覗き見して、手元で上記の計算式を回せば、ランダムスロットの中身を図鑑から取得できてしまいます。よって、この方法はダメです。

次に、性質2から満たそうとしてみましょう。自分にだけ見えて、相手には見えないようにするには、愚直に Commit-Reveal Scheme を使うと良さそうです。まずは自分の手元で秘密の乱数 $s$ を発行し、$id=h(s)\ mod\ n$ でランダムスロットに割り当てられる番号を知ったのちに、相手にはバレないようにスマートコントラクトには別のハッシュ関数 $h'$ を用いて計算した $s$ の暗号文 $h'(s)$ を送信します (Commit-Reveal Scheme の Commit)。すると、相手からは $h'(s)$ は丸見えですが、ハッシュの原像困難性により、相手は暗号化されている元の秘密の乱数 $s$ を知ることはできません (Commit-Reveal Scheme の Hiding)。そのため、ランダムスロットの中身もわからなくなり、確かに性質2は満たされています。そして、後から自分は確かに秘密の乱数 $s$ を持っていたと証明 (Commit-Reveal Scheme の Reveal) できますし、別の乱数を持っていたと嘘をつくこともできません(Commit-Reveal Scheme の Binding)。ところが、性質1は満たされていません。というのも、秘密の乱数 $s$ を使うと $id$ で指定される図鑑のモンスターをランダムスロットに持ってこれることを自分はわかってしまうからです。そのため、もし過去に一度でも強いモンスターを引くことができる秘密の乱数 $s$ を知ってしまうと、何度でもその乱数を使用することで強いモンスターを意図的にランダムスロットに引き続けることができてしまいます。よって、この方法もダメです。***Commit-Reveal Scheme をそのまま適用するだけではランダムスロットの実現はできません。***

では、どうすれば良いのでしょうか？今回我々は Commit-Reveal Scheme を応用することで性質1と性質2を同時に満たすプロトコルを考案し、実際に POLYLEMMA に実装を行いました。そのプロトコルを紹介します。

ランダムスロットの計算方法を以下にします。$s$ は先ほどと同じくプレイヤーが秘密にしておく乱数です。$nonce$ はゲームから配布される乱数です。ランダムスロットをプレイヤーの持つ乱数とゲームの持つ乱数の二つを使って定義するということです。

$$
id=h(s,nonce)\mod\ n
$$

プロトコルは次のように進行します。プレイヤーはまず自分の乱数 $s$ を手元で作り、ハッシュ関数 $h'$ (おそらく $h$ でも良い) を使ってそれを暗号化して暗号文 $h'(s)$ を作り (Commit-Reveal Scheme の Commit に対応)、ゲームのスマートコントラクトに送ります。ゲームは暗号文を暗号文を受理したことを確認した後に、$nonce$ を返します。これにより入力が揃うので、プレイヤーは自分のランダムスロットにどのキャラクターが割り当てられるかを知ることがでいます。***このプロトコルは、メッセージを送る順番が非常に重要です。***

![Untitled](README%20%E8%8D%89%E6%A1%88%2006ef9071268745e48c0cb1e9e868558a/Untitled%2016.png)

それでは、このシンプルなプロトコルが確かに性質1と性質2の両方を満たしていることを確認していきましょう。

性質1ですが、まずプレイヤーが $s$ を確定する前の時点ではプレイヤーは $nonce$ を知りません。手元でどれだけたくさんの $s$ の候補を試そして特定の番号を引き当てようとしても、$nonce$ 次第で結果が変わってしまうので無理です。$nonce$ がものすごく短ければ、総当たりで試して、強い番号を引く確率が高い $s$ を選択できなくもないですが、$nonce$ が長くなれば、もはや不可能です。いずれにしろ、この方式ではプレイヤーは何も考えずに適当に $s$ を作る以上に意味のある行動を取れません。確かに性質1が満たされています。

では性質2はどうでしょうか？相手から見ると、プレイヤーの秘密の乱数はハッシュ関数で暗号化されており、$h'(s)$ しか見えていません。ゲームが送った $nonce$ は見えていますが、ハッシュの原像困難性により秘密の乱数 $s$ がわからない (Commit-Reveal Scheme の Hiding) ので入力の一部が欠けた状態で ハッシュ値の予測をせざるを得ず、秘密の乱数 $s$ が十分に長ければ総当たりで試すこともできません。性質2も満たされています。

ランダムスロットを出す場合は普通のバトルの Commit-Reveal において、Reveal の直前に Commit していた秘密の乱数 $s$ を Reveal によって公開することで他のプレイヤーが、確かに今から Reveal されるランダムスロットに割り当てられているキャラクターは、ゲーム開始時に確定したものと一致することを検証できるのです。

### バトル終了時の報酬の配布

バトル時には勝者に対してのみ報酬のPLMCoinが支払われ、敗者は無報酬・無支払い、引き分けの場合は両者報酬が支払われます。

勝者の報酬は、両プレイヤーそれぞれの合計レベルより計算され、レベル差が小さい・レベルが自分より大きいプレイヤーを倒した時により大きな報酬が得られるようになっています。

以下式が勝者の報酬になります。PLMCoinは育成に使用されるため、ポケットモンスターシリーズの経験値計算を参考に設計しました。

$$
\frac{51\times \rm{loserTotalLevel} \times (\rm{winnerTotalLevel}\times 2+ 102)^3}{(\rm{winnerTotalLevel} + \rm{loserTotalLevel}+ 102)^3} 
$$

Player AとPlayer Bの間で引き分けの場合、

Aの報酬が以下式で、Bの報酬も同様です。

$$
\frac{51\times \rm{TotalLevel}_A \times (\rm{TotalLevel}_A\times 2+ 102)^3}{(\rm{TotalLevel_A} + \rm{TotalLevel_B}+ 102)^3} 
$$

これにより、引き分けで配布される報酬の総量 < 勝ち負けがついた時に配布される報酬の総量 が成立しており、

勝利することに対しての相対的なインセンティブを高めています。
